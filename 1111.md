1、Super Guppy R1.2 by JustUncleL
2、Mean Reversion Channel - MRI Variant
3、FibFib AutoFib
4、Madrid Moving Average Ribbon



1、Super Guppy R1.2 by JustUncleL
```
//@version=6

indicator(title = 'Super Guppy R1.2 by JustUncleL', shorttitle = 'SuperGuppy', overlay = true)

//
//  Author:   JustUncleL
//  Revision: R1.2
//  Date:     6-Jan-2018
//
//  Description:
//  ============
//  This indicator is a Super Guppy version of standard Guppy GMMA as used in
//  "CM_GUPPY_EMA Revised R2 by JustUncleL". Guppy is designed to capture the 
//  inferred behaviour of traders and investors by using two groups of averages.
//  In this version of Super Guppy Traders Group of EMAs are: 
//    EMA3 to EMA23 step 2 (Aqua=Uptrend, Blue=downtrend)
//  and Investors Group EMAs are: 
//    EMA25 to EMA70 step 3 (Lime=Uptrend, Red=downtrend)
//  (Gray=Trend not established or in a Pull Back).
//
//  The idea of Guppy EMAs is to use fractal repetitions to identify points of 
//  agreement and disagreement which precede significant trend changes.
//  For further info on how Guppy/Super Guppy can be used in trading please refer to
//  http://www.guppytraders.com/gup329.shtml
//  and many other articles available on the subject.
//
//  This indicator provides the following :
//  - Swing Arrow Alerts (Red for Sell and Green for Buy) to indicate PullBack entries
//    after new trend has been established. Also have option to wait for both fast and
//    slow to completely seperate (Confluence). Another option is to show alerts
//    when show arrows when Candle colour changes, this is handy when using Heikin Ashi
//    or Renko Charts.
//  - Trend Break Arrow Alerts (Blue for Sell and Aqua for Buy) to indicate entries
//    for agressive trend swing point and is calculated by cross over of the
//    average Traders EMA with the average Investors EMA. This was suggested option
//    by Guppy himself.
//  - Anchor time frame (0=current). This is the time frame that the Guppy MAs are
//    calculated for. This way 60 Guppy can be viewed on a 15 min chart to establish
//    tighter Stop Loss conditions. 
//  - Alert conditions are also created for the TradingView Alarm subsystem. Only
//    alerts for the selected alert options are generated.
//
//  References:
//  ===========
//  - Based on Daryl Guppy GMMA and
//    CM GMMA Original - https://www.tradingview.com/v/3rxOtFe0/
//  - http://www.guppytraders.com/gup329.shtml 
//
//
//  Revisions:
//  ==========
//  R1   - Original Version
//
//  R1.1 - Some changes to limit the number of Alerts that occur close together.
//
//  13-Jan-2018 
//       - Fix bug in Anchor calculations when chart Time frame not intraday.
//       - Fix bug in Break Arrow calculation, stop signal when Investor MAs
//         not change direction yet.
//       - Change Traders group to start colouring before Investors Group,
//         rather than together.
//
//  R1.2 14-Feb-2018 
//       - Fix bug in 1st pullback arrow calculation.
//       - Added option to display candle colours relative to Guppy Trend
//         indication.
//       06-Apr-2018
//       - Change Anchor to be based purely on Minutes, so 1 month=30240mins 
//         (21 trading days), 1 week=7200mins (5 trading days), 1 Day=1440mins.
//         This makes it more consistent across intraday and extraday chart Timeframes.
//
//
// -----------------------------------------------------------------------------
// Copyright 2014 Chris Moody
// Copyright 2018 JustUncleL
//
// This program is free software: you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published by
// the Free Software Foundation, either version 3 of the License, or
// any later version.
//
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
// 
// The GNU General Public License can be found here
// <http://www.gnu.org/licenses/>.
//
// -----------------------------------------------------------------------------
//


//
// Use Alternate Anchor TF for MAs 
anchor = input.int(0, minval = 0, maxval = 1440, title = 'Use Alternate Anchor TimeFrame (0=none, max=1440 (mins,D,W)')
//
src = input(close, title = 'EMA Source')
ShowBreak = input(true, title = 'Show Trend Break Arrow Alerts')
ShowSwing = input(true, title = 'Show Swing Arrow Alerts')
ShowCon = input(false, title = 'Give Only Fast+Slow Confluence Alerts')
uOCCswing = input(false, title = 'Add Bar Colour Changes to Swing Alerts')
Lookback = input(6, title = 'Alert Lookback Length')
ShowAvgs = input(false, title = 'Show Average Fast and Slow Guppy Curves')
show200 = input(false, title = 'Show 200 EMA Curve')
emaFilter = input(false, title = 'Filter Alerts with 200ema')
clrBars = input(false, title = 'Colour Candles to Guppy Trend state')

//
//Fast EMAs
lenF1 = input.int(3, minval = 1, title = 'Fast EMA 1')
lenF2 = input.int(5, minval = 1, title = 'Fast EMA 2')
lenF3 = input.int(7, minval = 1, title = 'Fast EMA 3')
lenF4 = input.int(9, minval = 1, title = 'Fast EMA 4')
lenF5 = input.int(11, minval = 1, title = 'Fast EMA 5')
lenF6 = input.int(13, minval = 1, title = 'Fast EMA 6')
lenF7 = input.int(15, minval = 1, title = 'Fast EMA 7')
lenF8 = input.int(17, minval = 1, title = 'Fast EMA 8')
lenF9 = input.int(19, minval = 1, title = 'Fast EMA 9')
lenF10 = input.int(21, minval = 1, title = 'Fast EMA 10')
lenF11 = input.int(23, minval = 1, title = 'Fast EMA 11')

//Slow EMAs
lenS1 = input.int(25, minval = 1, title = 'Slow EMA 1')
lenS2 = input.int(28, minval = 1, title = 'Slow EMA 2')
lenS3 = input.int(31, minval = 1, title = 'Slow EMA 3')
lenS4 = input.int(34, minval = 1, title = 'Slow EMA 4')
lenS5 = input.int(37, minval = 1, title = 'Slow EMA 5')
lenS6 = input.int(40, minval = 1, title = 'Slow EMA 6')
lenS7 = input.int(43, minval = 1, title = 'Slow EMA 7')
lenS8 = input.int(46, minval = 1, title = 'Slow EMA 8')
lenS9 = input.int(49, minval = 1, title = 'Slow EMA 9')
lenS10 = input.int(52, minval = 1, title = 'Slow EMA 10')
lenS11 = input.int(55, minval = 1, title = 'Slow EMA 11')
lenS12 = input.int(58, minval = 1, title = 'Slow EMA 12')
lenS13 = input.int(61, minval = 1, title = 'Slow EMA 13')
lenS14 = input.int(64, minval = 1, title = 'Slow EMA 14')
lenS15 = input.int(67, minval = 1, title = 'Slow EMA 15')
lenS16 = input.int(70, minval = 1, title = 'Slow EMA 16')

len = input.int(200, minval = 1, title = 'EMA 200 Length')

gold = #FFD700
AQUA = #00FFFFFF
BLUE = #0000FFFF
GRAY = #808080FF

// If have anchor specified, calculate the base multiplier.
mult = timeframe.isintraday ? anchor == 0 or timeframe.multiplier <= 0 or timeframe.multiplier >= anchor ? 1 : math.round(anchor / timeframe.multiplier) : 1
mult := timeframe.isdwm ? timeframe.isdaily ? anchor == 0 or timeframe.multiplier <= 0 or timeframe.multiplier >= anchor or anchor <= 1440 ? 1 : math.round(anchor / 1440) : timeframe.isweekly ? anchor == 0 or timeframe.multiplier <= 0 or timeframe.multiplier >= anchor or anchor <= 7200 ? 1 : math.round(anchor / 7200) : timeframe.ismonthly ? anchor == 0 or timeframe.multiplier <= 0 or timeframe.multiplier >= anchor or anchor <= 30240 ? 1 : math.round(anchor / 30240) : 1 : mult

//adjust MA lengths with Anchor Multiplier

//Fast EMA
emaF1 = ta.ema(src, lenF1 * mult)
emaF2 = ta.ema(src, lenF2 * mult)
emaF3 = ta.ema(src, lenF3 * mult)
emaF4 = ta.ema(src, lenF4 * mult)
emaF5 = ta.ema(src, lenF5 * mult)
emaF6 = ta.ema(src, lenF6 * mult)
emaF7 = ta.ema(src, lenF7 * mult)
emaF8 = ta.ema(src, lenF8 * mult)
emaF9 = ta.ema(src, lenF9 * mult)
emaF10 = ta.ema(src, lenF10 * mult)
emaF11 = ta.ema(src, lenF11 * mult)
//average
emafast = (emaF1 + emaF2 + emaF3 + emaF4 + emaF5 + emaF6 + emaF7 + emaF8 + emaF9 + emaF10 + emaF11) / 11
//
//Slow EMA
emaS1 = ta.ema(src, lenS1 * mult)
emaS2 = ta.ema(src, lenS2 * mult)
emaS3 = ta.ema(src, lenS3 * mult)
emaS4 = ta.ema(src, lenS4 * mult)
emaS5 = ta.ema(src, lenS5 * mult)
emaS6 = ta.ema(src, lenS6 * mult)
emaS7 = ta.ema(src, lenS7 * mult)
emaS8 = ta.ema(src, lenS8 * mult)
emaS9 = ta.ema(src, lenS9 * mult)
emaS10 = ta.ema(src, lenS10 * mult)
emaS11 = ta.ema(src, lenS11 * mult)
emaS12 = ta.ema(src, lenS12 * mult)
emaS13 = ta.ema(src, lenS13 * mult)
emaS14 = ta.ema(src, lenS14 * mult)
emaS15 = ta.ema(src, lenS15 * mult)
emaS16 = ta.ema(src, lenS16 * mult)
// average
emaslow = (emaS1 + emaS2 + emaS3 + emaS4 + emaS5 + emaS6 + emaS7 + emaS8 + emaS9 + emaS10 + emaS11 + emaS12 + emaS13 + emaS14 + emaS15 + emaS16) / 16
//
//EMA 200
ema200 = ta.ema(src, len * mult)

//Fast EMA Color Rules
colfastL = emaF1 > emaF2 and emaF2 > emaF3 and emaF3 > emaF4 and emaF4 > emaF5 and emaF5 > emaF6 and emaF6 > emaF7 and emaF7 > emaF8 and emaF8 > emaF9 and emaF9 > emaF10 and emaF10 > emaF11
colfastS = emaF1 < emaF2 and emaF2 < emaF3 and emaF3 < emaF4 and emaF4 < emaF5 and emaF5 < emaF6 and emaF6 < emaF7 and emaF7 < emaF8 and emaF8 < emaF9 and emaF9 < emaF10 and emaF10 < emaF11
//Slow EMA Color Rules
colslowL = emaS1 > emaS2 and emaS2 > emaS3 and emaS3 > emaS4 and emaS4 > emaS5 and emaS5 > emaS6 and emaS6 > emaS7 and emaS7 > emaS8 and emaS8 > emaS9 and emaS9 > emaS10 and emaS10 > emaS11 and emaS11 > emaS12 and emaS12 > emaS13 and emaS13 > emaS14 and emaS14 > emaS15 and emaS15 > emaS16
colslowS = emaS1 < emaS2 and emaS2 < emaS3 and emaS3 < emaS4 and emaS4 < emaS5 and emaS5 < emaS6 and emaS6 < emaS7 and emaS7 < emaS8 and emaS8 < emaS9 and emaS9 < emaS10 and emaS10 < emaS11 and emaS11 < emaS12 and emaS12 < emaS13 and emaS13 < emaS14 and emaS14 < emaS15 and emaS15 < emaS16

//Fast EMA Final Color Rules
colFinal = colfastL and emaS1 > emaS16 ? color.aqua : colfastS and emaS1 < emaS16 ? color.blue : color.gray
//Slow EMA Final Color Rules
colFinal2 = colslowL ? color.lime : colslowS ? color.red : color.gray

//Fast EMA Plots
p1 = plot(emaF1, title = 'Fast EMA 1', style = plot.style_line, linewidth = 2, color = colFinal)
plot(emaF2, title = 'Fast EMA 2', style = plot.style_line, linewidth = 1, color = colFinal)
plot(emaF3, title = 'Fast EMA 3', style = plot.style_line, linewidth = 1, color = colFinal)
plot(emaF4, title = 'Fast EMA 4', style = plot.style_line, linewidth = 1, color = colFinal)
plot(emaF5, title = 'Fast EMA 5', style = plot.style_line, linewidth = 1, color = colFinal)
plot(emaF6, title = 'Fast EMA 6', style = plot.style_line, linewidth = 1, color = colFinal)
plot(emaF7, title = 'Fast EMA 7', style = plot.style_line, linewidth = 1, color = colFinal)
plot(emaF8, title = 'Fast EMA 8', style = plot.style_line, linewidth = 1, color = colFinal)
plot(emaF9, title = 'Fast EMA 9', style = plot.style_line, linewidth = 1, color = colFinal)
plot(emaF10, title = 'Fast EMA 10', style = plot.style_line, linewidth = 1, color = colFinal)
p2 = plot(emaF11, title = 'Fast EMA 11', style = plot.style_line, linewidth = 1, color = colFinal)
plot(ShowAvgs ? emafast : na, title = 'Fast Avg', style = plot.style_circles, join = true, linewidth = 2, color = color.new(gold, 10))

//
fill(p1, p2, color = color.new(color.silver, 95))

//Slow EMA Plots
p3 = plot(emaS1, title = 'Slow EMA 1', style = plot.style_line, linewidth = 2, color = colFinal2)
plot(emaS2, title = 'Slow EMA 2', style = plot.style_line, linewidth = 1, color = colFinal2)
plot(emaS3, title = 'Slow EMA 3', style = plot.style_line, linewidth = 1, color = colFinal2)
plot(emaS4, title = 'Slow EMA 4', style = plot.style_line, linewidth = 1, color = colFinal2)
plot(emaS5, title = 'Slow EMA 5', style = plot.style_line, linewidth = 1, color = colFinal2)
plot(emaS6, title = 'Slow EMA 6', style = plot.style_line, linewidth = 1, color = colFinal2)
plot(emaS7, title = 'Slow EMA 7', style = plot.style_line, linewidth = 1, color = colFinal2)
plot(emaS8, title = 'Slow EMA 8', style = plot.style_line, linewidth = 1, color = colFinal2)
plot(emaS9, title = 'Slow EMA 9', style = plot.style_line, linewidth = 1, color = colFinal2)
plot(emaS10, title = 'Slow EMA 10', style = plot.style_line, linewidth = 1, color = colFinal2)
plot(emaS11, title = 'Slow EMA 11', style = plot.style_line, linewidth = 1, color = colFinal2)
plot(emaS12, title = 'Slow EMA 12', style = plot.style_line, linewidth = 1, color = colFinal2)
plot(emaS13, title = 'Slow EMA 13', style = plot.style_line, linewidth = 1, color = colFinal2)
plot(emaS14, title = 'Slow EMA 14', style = plot.style_line, linewidth = 1, color = colFinal2)
plot(emaS15, title = 'Slow EMA 15', style = plot.style_line, linewidth = 1, color = colFinal2)
p4 = plot(emaS16, title = 'Slow EMA 16', style = plot.style_line, linewidth = 2, color = colFinal2)
plot(ShowAvgs ? emaslow : na, title = 'Slow Avg', style = plot.style_circles, join = true, linewidth = 2, color = color.new(color.fuchsia, 10))
//
fill(p3, p4, color = color.new(color.silver, 95))

plot(show200 ? ema200 : na, title = 'EMA 200', style = plot.style_circles, join = true, linewidth = 2, color = color.new(color.black, 10))

//Fast EMA Final Color Rules
c = colfastL and emaS1 > emaS16 ? AQUA : colfastS and emaS1 < emaS16 ? BLUE : GRAY
barcolor(clrBars ? c : na, title = 'Guppy Bar Colors')

// Generate Alert Arrows
buy = 0
sell = 0
buybreak = 0
sellbreak = 0
//
buy := emafast > emaslow and emaS1 > emaS16 and not colslowS and colfastL and (not ShowCon or colslowL) and (not emaFilter or emafast > ema200) ? nz(buy[1]) > 0 ? buy[1] + 1 : 1 : 0
sell := emafast < emaslow and emaS1 < emaS16 and not colslowL and colfastS and (not ShowCon or colslowS) and (not emaFilter or emafast < ema200) ? nz(sell[1]) > 0 ? sell[1] + 1 : 1 : 0
buy := buy > 1 and colfastL and uOCCswing and close[1] < open[1] and close > open ? 1 : buy
sell := sell > 1 and colfastS and uOCCswing and close[1] > open[1] and close < open ? 1 : sell
//
buybreak := emafast > emaslow and not colslowS and (not emaFilter or emafast > ema200) ? nz(buybreak[1]) > 0 ? buybreak[1] + 1 : 1 : 0
sellbreak := emafast < emaslow and not colslowL and (not emaFilter or emafast < ema200) ? nz(sellbreak[1]) > 0 ? sellbreak[1] + 1 : 1 : 0
//
// Plot buy swing arrow with larger and wider shape and white text
plotshape(ShowSwing and buy == 1 and ta.barssince(nz(buy[1], 1) == 1) > Lookback, title = 'BUY Swing Arrow', location = location.belowbar, color = color.new(color.lime, 0), style = shape.labelup, text = 'BUY信号', textcolor = color.new(#FFFFFF, 0), size = size.small)

// Plot sell swing arrow with larger and wider shape and white text
plotshape(ShowSwing and sell == 1 and ta.barssince(nz(sell[1], 1) == 1) > Lookback, title = 'SELL Swing Arrow', location = location.abovebar, color = color.new(color.red, 0), style = shape.labeldown, text = 'SELL信号', textcolor = color.new(#FFFFFF, 0), size = size.small)

// Plot buy break arrow with larger and wider shape and white text
plotshape(ShowBreak and buybreak == 1 and ta.barssince(nz(sellbreak[1], 1) == 1) > Lookback and ta.barssince(nz(buybreak[1], 1) == 1) > Lookback, title = 'BUY Break Arrow', location = location.belowbar, color = color.new(color.aqua, 0), style = shape.labelup, text = '激进BUY', textcolor = color.new(#bb00ff, 0), size = size.small)

// Plot sell break arrow with larger and wider shape and white text
plotshape(ShowBreak and sellbreak == 1 and ta.barssince(nz(buybreak[1], 1) == 1) > Lookback and ta.barssince(nz(sellbreak[1], 1) == 1) > Lookback, title = 'SELL Break Arrow', location = location.abovebar, color = color.new(color.blue, 0), style = shape.labeldown, text = '激进SELL', textcolor = color.new(#bb00ff, 0), size = size.small)

// Generate only Alarms that are selected.
gAlert = ShowSwing and (buy == 1 and ta.barssince(nz(buy[1], 1) == 1) > Lookback or sell == 1 and ta.barssince(nz(sell[1], 1) == 1) > Lookback) or ShowBreak and (buybreak == 1 or sellbreak == 1) and ta.barssince(nz(buybreak[1], 1) == 1) > Lookback and ta.barssince(nz(sellbreak[1], 1) == 1) > Lookback
alertcondition(gAlert, title = 'Guppy Alert Arrow', message = 'Guppy Alert')
alertcondition(ShowSwing and buy == 1 and ta.barssince(nz(buy[1], 1) == 1) > Lookback or ShowBreak and buybreak == 1 and ta.barssince(nz(buybreak[1], 1) == 1) > Lookback and ta.barssince(nz(sellbreak[1], 1) == 1) > Lookback, title = 'Buy Arrow', message = 'BUY')
alertcondition(ShowSwing and sell == 1 and ta.barssince(nz(sell[1], 1) == 1) > Lookback or ShowBreak and sellbreak == 1 and ta.barssince(nz(buybreak[1], 1) == 1) > Lookback and ta.barssince(nz(sellbreak[1], 1) == 1) > Lookback, title = 'Sell Arrow', message = 'SELL')

//
//eof

```




2、Mean Reversion Channel - MRI Variant
```
// This source code is subject to the terms of the Mozilla Public License 2.0 at https://mozilla.org/MPL/2.0/
// REUSING THIS CODE: You are welcome to reuse this code without permission, including in closed-source publications, as long as proper credits are given :)
// Author: ©fareidzulkifli

// Description : 
// Mean Reversion Channel objective, based on Mean Reversion theory (everything has a tendency to revert back to its mean), is to help visualizing: 
//     Inner Channel -> Dynamic Support and Resistance 
//     Outer Channel -> Overbought/Oversold Zone which may signal consolidation phase or potential reversal due to unsustainable move

// The concept of this indicator oriiginally derived from Keltner Channel (The Keltner Channel was first introduced by Chester Keltner in the 1960s. The original formula used simple moving averages (SMA) and the high-low price range to calculate the bands. In the 1980s, a new formula was introduced that used ATR.)
// Instead if using SMA/EMA, this indicator used SuperSmoother MA as it's mean with longer lookback period (default to 200) to get more stable channel line. i also added second level so the indicator will have inner and outer channel
// Details of each filtering type used for mean calculation can be read in Ehlers Technical Papers: "Swiss Army Knife Indicator" and/or his book "Cybernetics Analysis for Stock and Futures"

// Disclaimer:
// Past performance is not an indicator of future results.
// My opinions are my own and do not constitute financial advice in any way whatsoever. 
// Nothing published by me constitutes an investment/trading recommendation, nor should any data or Content published by me be relied upon for any investment/trading activities.
// I strongly recommends that you perform your own independent research and/or speak with a qualified investment professional before making any financial decisions.

// Any ideas to further improve this indicator are welcome :)

//@version=6
indicator('Mean Reversion Channel - MRI Variant', shorttitle = 'MRC', overlay = true, format = format.inherit)

//************************************************************************************************************
// Parameter
//************************************************************************************************************

indiSet = input(false, '═════════ MRC Parameter ════════')
source = input(hlc3, title = 'Price Source')
type = input.string('SuperSmoother', title = 'Filter Type', options = ['SuperSmoother', 'Ehlers EMA', 'Gaussian', 'Butterworth', 'BandStop', 'SMA', 'EMA', 'RMA'])
length = input.int(200, title = 'Lookback Period', minval = 1)
innermult = input.float(1.0, title = 'Inner Channel Size Multiplier', minval = 0.1)
outermult = input.float(2.415, title = 'Outer Channel Size Multiplier', minval = 0.1)

ChartSet = input(false, '═════════ Chart Setting ════════')
drawchannel = input(true, title = 'Draw Channel')
displayzone = input(true, title = 'Draw Zone (With Channel)')
zonetransp = input.int(60, title = 'Zone Transparency', minval = 0, maxval = 100)
displayline = input(true, title = 'Display Line Extension')

MTFSet = input(false, '═════════ MTF Setting ════════')
enable_mtf = input(true, title = 'Enable Multiple TimeFrame Analysis')
mtf_disp_typ = input.string('On Hover', title = 'MTF Display Type', options = ['Always Display', 'On Hover'])
mtf_typ = input.string('Auto', title = 'Multiple TimeFrame Type', options = ['Auto', 'Custom'])
mtf_lvl1 = input.timeframe('D', title = 'Custom MTF Level 1')
mtf_lvl2 = input.timeframe('W', title = 'Custom MTF Level 2')

//************************************************************************************************************
// Functions Start {
//************************************************************************************************************
var pi = 2 * math.asin(1)
var mult = pi * innermult
var mult2 = pi * outermult
var gradsize = 0.5
var gradtransp = zonetransp

//-----------------------
// Ehler SwissArmyKnife Function
//-----------------------
SAK_smoothing(_type, _src, _length) =>
    c0 = 1.0
    c1 = 0.0
    b0 = 1.0
    b1 = 0.0
    b2 = 0.0
    a1 = 0.0
    a2 = 0.0
    alpha = 0.0
    beta = 0.0
    gamma = 0.0
    cycle = 2 * pi / _length

    if _type == 'Ehlers EMA'
        alpha := (math.cos(cycle) + math.sin(cycle) - 1) / math.cos(cycle)
        b0 := alpha
        a1 := 1 - alpha
        a1
    if _type == 'Gaussian'
        beta := 2.415 * (1 - math.cos(cycle))
        alpha := -beta + math.sqrt(beta * beta + 2 * beta)
        c0 := alpha * alpha
        a1 := 2 * (1 - alpha)
        a2 := -(1 - alpha) * (1 - alpha)
        a2
    if _type == 'Butterworth'
        beta := 2.415 * (1 - math.cos(cycle))
        alpha := -beta + math.sqrt(beta * beta + 2 * beta)
        c0 := alpha * alpha / 4
        b1 := 2
        b2 := 1
        a1 := 2 * (1 - alpha)
        a2 := -(1 - alpha) * (1 - alpha)
        a2
    if _type == 'BandStop'
        beta := math.cos(cycle)
        gamma := 1 / math.cos(cycle * 2 * 0.1) // delta default to 0.1. Acceptable delta -- 0.05<d<0.5
        alpha := gamma - math.sqrt(gamma * gamma - 1)
        c0 := (1 + alpha) / 2
        b1 := -2 * beta
        b2 := 1
        a1 := beta * (1 + alpha)
        a2 := -alpha
        a2
    if _type == 'SMA'
        c1 := 1 / _length
        b0 := 1 / _length
        a1 := 1
        a1
    if _type == 'EMA'
        alpha := 2 / (_length + 1)
        b0 := alpha
        a1 := 1 - alpha
        a1
    if _type == 'RMA'
        alpha := 1 / _length
        b0 := alpha
        a1 := 1 - alpha
        a1

    _Input = _src
    _Output = 0.0
    _Output := c0 * (b0 * _Input + b1 * nz(_Input[1]) + b2 * nz(_Input[2])) + a1 * nz(_Output[1]) + a2 * nz(_Output[2]) - c1 * nz(_Input[_length])
    _Output

//-----------------------
// SuperSmoother Function
//-----------------------
supersmoother(_src, _length) =>
    s_a1 = math.exp(-math.sqrt(2) * pi / _length)
    s_b1 = 2 * s_a1 * math.cos(math.sqrt(2) * pi / _length)
    s_c3 = -math.pow(s_a1, 2)
    s_c2 = s_b1
    s_c1 = 1 - s_c2 - s_c3
    ss = 0.0
    ss := s_c1 * _src + s_c2 * nz(ss[1], _src[1]) + s_c3 * nz(ss[2], _src[2])
    ss

//-----------------------
// Auto TimeFrame Function
//-----------------------
// ————— Converts current chart resolution into a float minutes value.
f_resInMinutes() =>
    _resInMinutes = timeframe.multiplier * (timeframe.isseconds ? 1. / 60 : timeframe.isminutes ? 1. : timeframe.isdaily ? 60. * 24 : timeframe.isweekly ? 60. * 24 * 7 : timeframe.ismonthly ? 60. * 24 * 30.4375 : na)
    _resInMinutes

get_tf(_lvl) =>
    y = f_resInMinutes()
    z = timeframe.period
    if mtf_typ == 'Auto'
        if y < 1
            z := _lvl == 1 ? '1' : _lvl == 2 ? '5' : z
            z
        else if y <= 3
            z := _lvl == 1 ? '5' : _lvl == 2 ? '15' : z
            z
        else if y <= 10
            z := _lvl == 1 ? '15' : _lvl == 2 ? '60' : z
            z
        else if y <= 30
            z := _lvl == 1 ? '60' : _lvl == 2 ? '240' : z
            z
        else if y <= 120
            z := _lvl == 1 ? '240' : _lvl == 2 ? 'D' : z
            z
        else if y <= 240
            z := _lvl == 1 ? 'D' : _lvl == 2 ? 'W' : z
            z
        else if y <= 1440
            z := _lvl == 1 ? 'W' : _lvl == 2 ? 'M' : z
            z
        else if y <= 10080
            z := _lvl == 1 ? 'M' : z
            z
        else
            z := z
            z
    else
        z := _lvl == 1 ? mtf_lvl1 : _lvl == 2 ? mtf_lvl2 : z
        z

    z

//-----------------------
// Mean Reversion Channel Function
//-----------------------
get_mrc() =>
    v_condition = 0
    v_meanline = source
    v_meanrange = supersmoother(ta.tr, length)

    //-- Get Line value
    if type == 'SuperSmoother'
        v_meanline := supersmoother(source, length)
        v_meanline

    if type != 'SuperSmoother'
        v_meanline := SAK_smoothing(type, source, length)
        v_meanline

    v_upband1 = v_meanline + v_meanrange * mult
    v_loband1 = v_meanline - v_meanrange * mult
    v_upband2 = v_meanline + v_meanrange * mult2
    v_loband2 = v_meanline - v_meanrange * mult2

    //-- Check Condition
    if close > v_meanline
        v_upband2_1 = v_upband2 + v_meanrange * gradsize * 4
        v_upband2_9 = v_upband2 + v_meanrange * gradsize * -4
        if high >= v_upband2_9 and high < v_upband2
            v_condition := 1
            v_condition
        else if high >= v_upband2 and high < v_upband2_1
            v_condition := 2
            v_condition
        else if high >= v_upband2_1
            v_condition := 3
            v_condition
        else if close <= v_meanline + v_meanrange
            v_condition := 4
            v_condition
        else
            v_condition := 5
            v_condition

    if close < v_meanline
        v_loband2_1 = v_loband2 - v_meanrange * gradsize * 4
        v_loband2_9 = v_loband2 - v_meanrange * gradsize * -4
        if low <= v_loband2_9 and low > v_loband2
            v_condition := -1
            v_condition
        else if low <= v_loband2 and low > v_loband2_1
            v_condition := -2
            v_condition
        else if low <= v_loband2_1
            v_condition := -3
            v_condition
        else if close >= v_meanline + v_meanrange
            v_condition := -4
            v_condition
        else
            v_condition := -5
            v_condition

    [v_meanline, v_meanrange, v_upband1, v_loband1, v_upband2, v_loband2, v_condition]

//-----------------------
// MTF Analysis
//-----------------------

get_stat(_cond) =>
    ret = 'Price at Mean Line\n'
    if _cond == 1
        ret := 'Overbought (Weak)\n'
        ret
    else if _cond == 2
        ret := 'Overbought\n'
        ret
    else if _cond == 3
        ret := 'Overbought (Strong)\n'
        ret
    else if _cond == 4
        ret := 'Price Near Mean\n'
        ret
    else if _cond == 5
        ret := 'Price Above Mean\n'
        ret
    else if _cond == -1
        ret := 'Oversold (Weak)\n'
        ret
    else if _cond == -2
        ret := 'Oversold\n'
        ret
    else if _cond == -3
        ret := 'Oversold (Strong)\n'
        ret
    else if _cond == -4
        ret := 'Price Near Mean\n'
        ret
    else if _cond == -5
        ret := 'Price Below Mean\n'
        ret
    ret

//-----------------------
// Chart Drawing Function
//-----------------------
format_price(x) =>
    y = str.tostring(x, '0.00000')
    if x > 10
        y := str.tostring(x, '0.000')
        y
    if x > 1000
        y := str.tostring(x, '0.00')
        y
    y

f_PriceLine(_ref, linecol) =>
    line.new(x1 = bar_index, x2 = bar_index - 1, y1 = _ref, y2 = _ref, extend = extend.left, color = linecol)

f_MTFLabel(_txt, _yloc) =>
    label.new(x = time + math.round(ta.change(time) * 20), y = _yloc, xloc = xloc.bar_time, text = mtf_disp_typ == 'Always Display' ? _txt : 'Check MTF', tooltip = mtf_disp_typ == 'Always Display' ? '' : _txt, color = color.black, textcolor = color.white, size = size.normal, style = mtf_disp_typ == 'On Hover' and displayline ? label.style_label_lower_left : label.style_label_left, textalign = text.align_left)

//} Function End

//************************************************************************************************************
// Calculate Channel
//************************************************************************************************************
var tf_0 = timeframe.period
var tf_1 = get_tf(1)
var tf_2 = get_tf(2)

[meanline, meanrange, upband1, loband1, upband2, loband2, condition] = get_mrc()
[mtf1_meanline, mtf1_meanrange, mtf1_upband1, mtf1_loband1, mtf1_upband2, mtf1_loband2, mtf1_condition] = request.security(syminfo.tickerid, tf_1, get_mrc())
[mtf2_meanline, mtf2_meanrange, mtf2_upband1, mtf2_loband1, mtf2_upband2, mtf2_loband2, mtf2_condition] = request.security(syminfo.tickerid, tf_2, get_mrc())

//************************************************************************************************************
// Drawing Start {
//************************************************************************************************************
float p_meanline = drawchannel ? meanline : na
float p_upband1 = drawchannel ? upband1 : na
float p_loband1 = drawchannel ? loband1 : na
float p_upband2 = drawchannel ? upband2 : na
float p_loband2 = drawchannel ? loband2 : na

z = plot(p_meanline, color = color.new(#FFCD00, 0), style = plot.style_line, title = ' Mean', linewidth = 2)
x1 = plot(p_upband1, color = color.new(color.green, 50), style = plot.style_circles, title = ' R1', linewidth = 1)
x2 = plot(p_loband1, color = color.new(color.green, 50), style = plot.style_circles, title = ' S1', linewidth = 1)
y1 = plot(p_upband2, color = color.new(color.red, 50), style = plot.style_line, title = ' R2', linewidth = 1)
y2 = plot(p_loband2, color = color.new(color.red, 50), style = plot.style_line, title = ' S2', linewidth = 1)

//-----------------------
// Draw zone
//-----------------------
//---
var color1 = #FF0000
var color2 = #FF4200
var color3 = #FF5D00
var color4 = #FF7400
var color5 = #FF9700
var color6 = #FFAE00
var color7 = #FFC500
var color8 = #FFCD00
//---
float upband2_1 = drawchannel and displayzone ? upband2 + meanrange * gradsize * 4 : na
float loband2_1 = drawchannel and displayzone ? loband2 - meanrange * gradsize * 4 : na
float upband2_2 = drawchannel and displayzone ? upband2 + meanrange * gradsize * 3 : na
float loband2_2 = drawchannel and displayzone ? loband2 - meanrange * gradsize * 3 : na
float upband2_3 = drawchannel and displayzone ? upband2 + meanrange * gradsize * 2 : na
float loband2_3 = drawchannel and displayzone ? loband2 - meanrange * gradsize * 2 : na
float upband2_4 = drawchannel and displayzone ? upband2 + meanrange * gradsize * 1 : na
float loband2_4 = drawchannel and displayzone ? loband2 - meanrange * gradsize * 1 : na
float upband2_5 = drawchannel and displayzone ? upband2 + meanrange * gradsize * 0 : na
float loband2_5 = drawchannel and displayzone ? loband2 - meanrange * gradsize * 0 : na
float upband2_6 = drawchannel and displayzone ? upband2 + meanrange * gradsize * -1 : na
float loband2_6 = drawchannel and displayzone ? loband2 - meanrange * gradsize * -1 : na
float upband2_7 = drawchannel and displayzone ? upband2 + meanrange * gradsize * -2 : na
float loband2_7 = drawchannel and displayzone ? loband2 - meanrange * gradsize * -2 : na
float upband2_8 = drawchannel and displayzone ? upband2 + meanrange * gradsize * -3 : na
float loband2_8 = drawchannel and displayzone ? loband2 - meanrange * gradsize * -3 : na
float upband2_9 = drawchannel and displayzone ? upband2 + meanrange * gradsize * -4 : na
float loband2_9 = drawchannel and displayzone ? loband2 - meanrange * gradsize * -4 : na

//---
plot_upband2_1 = plot(upband2_1, color = na, display = display.none)
plot_loband2_1 = plot(loband2_1, color = na, display = display.none)
plot_upband2_2 = plot(upband2_2, color = na, display = display.none)
plot_loband2_2 = plot(loband2_2, color = na, display = display.none)
plot_upband2_3 = plot(upband2_3, color = na, display = display.none)
plot_loband2_3 = plot(loband2_3, color = na, display = display.none)
plot_upband2_4 = plot(upband2_4, color = na, display = display.none)
plot_loband2_4 = plot(loband2_4, color = na, display = display.none)
plot_upband2_5 = plot(upband2_5, color = na, display = display.none)
plot_loband2_5 = plot(loband2_5, color = na, display = display.none)
plot_upband2_6 = plot(upband2_6, color = na, display = display.none)
plot_loband2_6 = plot(loband2_6, color = na, display = display.none)
plot_upband2_7 = plot(upband2_7, color = na, display = display.none)
plot_loband2_7 = plot(loband2_7, color = na, display = display.none)
plot_upband2_8 = plot(upband2_8, color = na, display = display.none)
plot_loband2_8 = plot(loband2_8, color = na, display = display.none)
plot_upband2_9 = plot(upband2_9, color = na, display = display.none)
plot_loband2_9 = plot(loband2_9, color = na, display = display.none)

//---
fill(plot_upband2_1, plot_upband2_2, color = color1)
fill(plot_loband2_1, plot_loband2_2, color = color1)
fill(plot_upband2_2, plot_upband2_3, color = color2)
fill(plot_loband2_2, plot_loband2_3, color = color2)
fill(plot_upband2_3, plot_upband2_4, color = color3)
fill(plot_loband2_3, plot_loband2_4, color = color3)
fill(plot_upband2_4, plot_upband2_5, color = color4)
fill(plot_loband2_4, plot_loband2_5, color = color4)
fill(plot_upband2_5, plot_upband2_6, color = color5)
fill(plot_loband2_5, plot_loband2_6, color = color5)
fill(plot_upband2_6, plot_upband2_7, color = color6)
fill(plot_loband2_6, plot_loband2_7, color = color6)
fill(plot_upband2_7, plot_upband2_8, color = color7)
fill(plot_loband2_7, plot_loband2_8, color = color7)
fill(plot_upband2_8, plot_upband2_9, color = color8)
fill(plot_loband2_8, plot_loband2_9, color = color8)

//-----------------------
// Plot Extension
//-----------------------
if displayline and enable_mtf and mtf_disp_typ == 'Always Display'
    displayline := false
    displayline

var line mean = na
line.delete(mean)
mean := displayline ? f_PriceLine(meanline, #FFCD00) : na
var line res1 = na
line.delete(res1)
res1 := displayline ? f_PriceLine(upband1, color.green) : na
var line sup1 = na
line.delete(sup1)
sup1 := displayline ? f_PriceLine(loband1, color.green) : na
var line res2 = na
line.delete(res2)
res2 := displayline ? f_PriceLine(upband2, color.red) : na
var line sup2 = na
line.delete(sup2)
sup2 := displayline ? f_PriceLine(loband2, color.red) : na

//--------------
// Prep MTF Label
//--------------
var brl = '\n--------------------------------------'
dist_0 = 'Distance from Mean: ' + str.tostring((close - meanline) / close * 100, '#.##') + ' %'
dist_1 = 'Distance from Mean: ' + str.tostring((close - mtf1_meanline) / close * 100, '#.##') + ' %'
dist_2 = 'Distance from Mean: ' + str.tostring((close - mtf2_meanline) / close * 100, '#.##') + ' %'

var title = 'Mean Reversion Channel\nMultiple TimeFrame Analysis' + brl
tf0 = '\n\nTimeframe: ' + tf_0 + ' (Current)\n\nStatus: ' + get_stat(condition) + dist_0 + brl

tf1 = not timeframe.ismonthly ? '\n\nTimeframe: ' + tf_1 + '\n\nStatus: ' + get_stat(mtf1_condition) + dist_1 + brl : ''

tf2 = not timeframe.isweekly and not timeframe.ismonthly ? '\n\nTimeframe: ' + tf_2 + '\n\nStatus: ' + get_stat(mtf2_condition) + dist_2 + brl : ''

mtf_lbl = title + tf0 + tf1 + tf2
var label label_mtf = na
label.delete(label_mtf)
label_mtf := enable_mtf ? f_MTFLabel(mtf_lbl, meanline) : na

//} Drawing End
```



3、FibFib AutoFib
```
//@version=6
indicator(title = 'FibFib FibFib', shorttitle = 'AutoFib', overlay = true)
fiblength = input(265)
maxr = ta.highest(close, fiblength)
minr = ta.lowest(close, fiblength)
ranr = maxr - minr

ON = plot(maxr, color = color.new(color.black, 0), title = '1')
SS = plot(maxr - 0.236 * ranr, title = '0.764', color = color.new(#3399FF, 0))
SO = plot(maxr - 0.382 * ranr, title = '0.618', color = color.new(color.blue, 0))
FI = plot(maxr - 0.50 * ranr, title = '0.5', color = color.new(color.lime, 0))
TE = plot(minr + 0.382 * ranr, title = '0.382', color = color.new(color.green, 0))
TT = plot(minr + 0.236 * ranr, title = '0.236', color = color.new(color.red, 0))
ZZ = plot(minr, title = '0', color = color.new(color.black, 0))

fill(ON, SS, color = color.new(color.red, 90))
fill(SS, SO, color = color.new(#3399FF, 90))
fill(SO, FI, color = color.new(color.lime, 90))
fill(FI, TE, color = color.new(color.lime, 90))
fill(TE, TT, color = color.new(#3399FF, 90))
fill(TT, ZZ, color = color.new(color.red, 90))
```


4、Madrid Moving Average Ribbon
```
//@version=6
indicator('Madrid Moving Average Ribbon v6', shorttitle = 'MMAR v6', overlay = true)
exponential = input.bool(true, title = 'Exponential MA')

src = close

// Moving averages
ma05 = exponential ? ta.ema(src, 5) : ta.sma(src, 5)
ma10 = exponential ? ta.ema(src, 10) : ta.sma(src, 10)
ma15 = exponential ? ta.ema(src, 15) : ta.sma(src, 15)
ma20 = exponential ? ta.ema(src, 20) : ta.sma(src, 20)
ma25 = exponential ? ta.ema(src, 25) : ta.sma(src, 25)
ma30 = exponential ? ta.ema(src, 30) : ta.sma(src, 30)
ma35 = exponential ? ta.ema(src, 35) : ta.sma(src, 35)
ma40 = exponential ? ta.ema(src, 40) : ta.sma(src, 40)
ma45 = exponential ? ta.ema(src, 45) : ta.sma(src, 45)
ma50 = exponential ? ta.ema(src, 50) : ta.sma(src, 50)
ma55 = exponential ? ta.ema(src, 55) : ta.sma(src, 55)
ma60 = exponential ? ta.ema(src, 60) : ta.sma(src, 60)
ma65 = exponential ? ta.ema(src, 65) : ta.sma(src, 65)
ma70 = exponential ? ta.ema(src, 70) : ta.sma(src, 70)
ma75 = exponential ? ta.ema(src, 75) : ta.sma(src, 75)
ma80 = exponential ? ta.ema(src, 80) : ta.sma(src, 80)
ma85 = exponential ? ta.ema(src, 85) : ta.sma(src, 85)
ma90 = exponential ? ta.ema(src, 90) : ta.sma(src, 90)
ma100 = exponential ? ta.ema(src, 100) : ta.sma(src, 100)

// Color function for moving averages
maColor(ma, maRef) =>
    if ta.change(ma) >= 0 and ma > maRef
        color.lime
    else if ta.change(ma) < 0 and ma > maRef
        color.maroon
    else if ta.change(ma) <= 0 and ma < maRef
        color.red
    else if ta.change(ma) >= 0 and ma < maRef
        color.green
    else
        color.gray

leadMAColor = maColor(ma05, ma100)

// Plotting moving averages
plot(ma05, color = leadMAColor, linewidth = 3, title = 'MMA05')
plot(ma10, color = maColor(ma10, ma100), linewidth = 1, title = 'MMA10')
plot(ma15, color = maColor(ma15, ma100), linewidth = 1, title = 'MMA15')
plot(ma20, color = maColor(ma20, ma100), linewidth = 1, title = 'MMA20')
plot(ma25, color = maColor(ma25, ma100), linewidth = 1, title = 'MMA25')
plot(ma25, color = maColor(ma30, ma100), linewidth = 1, title = 'MMA30')
plot(ma35, color = maColor(ma35, ma100), linewidth = 1, title = 'MMA35')
plot(ma40, color = maColor(ma40, ma100), linewidth = 1, title = 'MMA40')
plot(ma45, color = maColor(ma45, ma100), linewidth = 1, title = 'MMA45')
plot(ma50, color = maColor(ma50, ma100), linewidth = 1, title = 'MMA50')
plot(ma55, color = maColor(ma55, ma100), linewidth = 1, title = 'MMA55')
plot(ma60, color = maColor(ma60, ma100), linewidth = 1, title = 'MMA60')
plot(ma65, color = maColor(ma65, ma100), linewidth = 1, title = 'MMA65')
plot(ma70, color = maColor(ma70, ma100), linewidth = 1, title = 'MMA70')
plot(ma75, color = maColor(ma75, ma100), linewidth = 1, title = 'MMA75')
plot(ma80, color = maColor(ma80, ma100), linewidth = 1, title = 'MMA80')
plot(ma85, color = maColor(ma85, ma100), linewidth = 1, title = 'MMA85')
plot(ma90, color = maColor(ma90, ma100), linewidth = 3, title = 'MMA90')
```
